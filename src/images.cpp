#include "images.h"
#include "display.h"

// Example image data
const uint16_t exampleImage[] = {

  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};



// Draw bitmap with transparency
void drawBitmap(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  for (int row = 0; row < height; row++) {
    for (int col = 0; col < width; col++) {
      uint16_t pixelColor = bitmap[row * width + col];
      if (pixelColor != 0x0000) {
        display->drawPixel(x + col, y + row, pixelColor);
      }
    }
  }
}

// Draw bitmap without transparency
void drawBitmapFast(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  for (int row = 0; row < height; row++) {
    for (int col = 0; col < width; col++) {
      uint16_t pixelColor = bitmap[row * width + col];
      display->drawPixel(x + col, y + row, pixelColor);
    }
  }
}

// Interlaced rendering
void drawBitmapInterlaced(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  // Even rows first
  for (int row = 0; row < height; row += 2) {
    for (int col = 0; col < width; col++) {
      uint16_t pixelColor = bitmap[row * width + col];
      display->drawPixel(x + col, y + row, pixelColor);
    }
  }
  
  // Odd rows
  for (int row = 1; row < height; row += 2) {
    for (int col = 0; col < width; col++) {
      uint16_t pixelColor = bitmap[row * width + col];
      display->drawPixel(x + col, y + row, pixelColor);
    }
  }
}

// Hybrid interlaced rendering
void drawBitmapHybridInterlaced(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  static uint16_t evenRowBuffer[128];
  static uint16_t oddRowBuffer[128];
  
  // Even rows
  for (int row = 0; row < height; row += 2) {
    for (int col = 0; col < width; col++) {
      evenRowBuffer[col] = bitmap[row * width + col];
    }
    display->drawRGBBitmap(x, y + row, evenRowBuffer, width, 1);
  }
  
  // Odd rows
  for (int row = 1; row < height; row += 2) {
    for (int col = 0; col < width; col++) {
      oddRowBuffer[col] = bitmap[row * width + col];
    }
    display->drawRGBBitmap(x, y + row, oddRowBuffer, width, 1);
  }
}

// Ultra-fast bitmap drawing
inline void drawBitmapUltraFast(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  display->drawRGBBitmap(x, y, bitmap, width, height);
}

// Chunked bitmap drawing
void drawBitmapChunked(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  const int CHUNK_SIZE = 16;
  
  for (int rowStart = 0; rowStart < height; rowStart += CHUNK_SIZE) {
    int chunkHeight = min(CHUNK_SIZE, height - rowStart);
    const uint16_t* chunkData = bitmap + (rowStart * width);
    
    display->drawRGBBitmap(x, y + rowStart, chunkData, width, chunkHeight);
  }
}

// Interlaced with timing
void drawBitmapInterlacedTimed(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height, uint8_t delayMs) {
  drawBitmapChunked(display, bitmap, x, y, width, height);
  
  if (delayMs > 0) {
    delay(delayMs);
  }
}

// Draw bitmap from array
void drawBitmapFromArray(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  drawBitmap(display, bitmap, x, y, width, height);
}

// Show image at coordinates
void showImage(const uint16_t* bitmap, int width, int height, int x, int y) {
  display.fillScreen(BLACK);
  drawBitmap(&display, bitmap, x, y, width, height);
}

// Show image centered
void showCenteredImage(const uint16_t* bitmap, int width, int height) {
  int x = (OLED_WIDTH - width) / 2;
  int y = (OLED_HEIGHT - height) / 2;
  showImage(bitmap, width, height, x, y);
}

// DMA-accelerated bitmap drawing
void drawBitmapDMA(const uint16_t* bitmap, int x, int y, int width, int height) {
  extern void sendImageDMA(const uint16_t* imageData, int width, int height);
  sendImageDMA(bitmap, width, height);
}

// Multi-core image preparation
void drawBitmapMultiCore(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  drawBitmapUltraFast(display, bitmap, x, y, width, height);
}

// Direct memory mapping
void drawBitmapDirectMemory(const uint16_t* bitmap, int x, int y, int width, int height) {
  Serial.printf("Direct Memory Bitmap: %dx%d at (%d,%d)\n", width, height, x, y);
}

// Adaptive bitmap drawing
void drawBitmapAdaptive(Adafruit_GFX* display, const uint16_t* bitmap, int x, int y, int width, int height) {
  int pixelCount = width * height;
  
  if (pixelCount > 8192) {
    drawBitmapDMA(bitmap, x, y, width, height);
  } else if (pixelCount > 1024) {
    drawBitmapUltraFast(display, bitmap, x, y, width, height);
  } else {
    drawBitmapChunked(display, bitmap, x, y, width, height);
  }
} 