#!/usr/bin/env python3
"""
TTF Font to C Array Converter for ESP32 OLED Display
Converts TTF fonts to bitmap arrays for custom text rendering
"""

from PIL import Image, ImageDraw, ImageFont
import sys
import os
import json

def create_font_bitmap(font_path, char, size=16, color=(255, 255, 255)):
    """Create a bitmap for a single character"""
    try:
        # Load the font
        font = ImageFont.truetype(font_path, size)
        
        # Create a temporary image to measure text
        temp_img = Image.new('RGB', (1, 1), (0, 0, 0))
        temp_draw = ImageDraw.Draw(temp_img)
        
        # Get character dimensions
        bbox = temp_draw.textbbox((0, 0), char, font=font)
        char_width = bbox[2] - bbox[0]
        char_height = bbox[3] - bbox[1]
        
        # Create image for the character
        img = Image.new('RGB', (char_width, char_height), (0, 0, 0))
        draw = ImageDraw.Draw(img)
        
        # Draw the character
        draw.text((0, 0), char, font=font, fill=color)
        
        return img, char_width, char_height
        
    except Exception as e:
        print(f"Error creating bitmap for character '{char}': {e}")
        return None, 0, 0

def rgb888_to_rgb565(r, g, b):
    """Convert RGB888 to RGB565 format"""
    r = (r >> 3) & 0x1F
    g = (g >> 2) & 0x3F
    b = (b >> 3) & 0x1F
    return (r << 11) | (g << 5) | b

def image_to_rgb565_array(img):
    """Convert PIL image to RGB565 array"""
    width, height = img.size
    pixels = []
    
    for y in range(height):
        for x in range(width):
            r, g, b = img.getpixel((x, y))
            rgb565 = rgb888_to_rgb565(r, g, b)
            pixels.append(rgb565)
    
    return pixels, width, height

def generate_font_array(font_path, output_path, font_size=16, chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>? "):
    """Generate C array for font characters"""
    
    if not os.path.exists(font_path):
        print(f"Error: Font file '{font_path}' not found")
        return
    
    # Extract font name from path for function naming
    font_name = os.path.splitext(os.path.basename(font_path))[0].lower()
    font_prefix = font_name.replace('.', '_').replace('-', '_')
    
    print(f"Converting font: {font_path}")
    print(f"Font size: {font_size}px")
    print(f"Characters: {len(chars)}")
    print(f"Font prefix: {font_prefix}")
    
    # Generate C header
    c_header = f"""// Custom Font Generated from: {os.path.basename(font_path)}
// Font Size: {font_size}px
// Generated by convert_font.py

#ifndef {font_prefix.upper()}_FONT_H
#define {font_prefix.upper()}_FONT_H

#include <stdint.h>
#include <Adafruit_GFX.h>

// Font information
#define FONT_SIZE {font_size}
#define FONT_CHAR_COUNT {len(chars)}

// Character data structure
typedef struct {{
    uint16_t width;
    uint16_t height;
    const uint16_t* data;
}} FontChar;

// Font data
extern const FontChar customFont[FONT_CHAR_COUNT];

// Function declarations
int getCharIndex(char c);
void draw{font_prefix.capitalize()}Char(Adafruit_GFX* display, char c, int x, int y, uint16_t color);
void draw{font_prefix.capitalize()}Text(Adafruit_GFX* display, const char* text, int x, int y, uint16_t color);

#endif // {font_prefix.upper()}_FONT_H
"""
    
    # Generate C implementation
    c_impl = f"""// Custom Font Implementation
// Generated from: {os.path.basename(font_path)}

#include "{font_prefix}_font.h"
#include <Adafruit_GFX.h>

"""
    
    # Process each character
    char_data = []
    char_info = []
    
    for i, char in enumerate(chars):
        print(f"Processing character '{char}' ({i+1}/{len(chars)})")
        
        img, width, height = create_font_bitmap(font_path, char, font_size)
        
        if img is not None:
            pixels, w, h = image_to_rgb565_array(img)
            
            # Add character data
            char_data.append(f"// Character '{char}' ({w}x{h})\n")
            char_data.append(f"const uint16_t char_{i}_data[] = {{\n")
            
            # Format pixels (16 per line)
            for j in range(0, len(pixels), 16):
                line_pixels = pixels[j:j+16]
                char_data.append("  " + ", ".join([f"0x{p:04X}" for p in line_pixels]) + ",\n")
            
            char_data.append("};\n\n")
            
            # Add character info
            char_info.append(f"  {{ {w}, {h}, char_{i}_data }}, // '{char}'\n")
    
    # Complete the implementation
    c_impl += "".join(char_data)
    c_impl += f"""
// Font character lookup table
const FontChar customFont[FONT_CHAR_COUNT] = {{
{''.join(char_info)}}};

// Get character index in font array
int getCharIndex(char c) {{
    for (int i = 0; i < FONT_CHAR_COUNT; i++) {{
        // This is a simple mapping - you might want to improve this
        if (i < 26) {{ // A-Z
            if (c == 'A' + i) return i;
        }} else if (i < 52) {{ // a-z
            if (c == 'a' + (i - 26)) return i;
        }} else if (i < 62) {{ // 0-9
            if (c == '0' + (i - 52)) return i;
        }} else {{
            // Handle special characters
            const char special_chars[] = "!@#$%^&*()_+-=[]{{}}|;:,.<>? ";
            for (int j = 0; j < sizeof(special_chars) - 1; j++) {{
                if (c == special_chars[j]) return i;
            }}
        }}
    }}
    return 0; // Default to first character
}}

// Draw a single character
void draw{font_prefix.capitalize()}Char(Adafruit_GFX* display, char c, int x, int y, uint16_t color) {{
    int index = getCharIndex(c);
    if (index >= 0 && index < FONT_CHAR_COUNT) {{
        const FontChar* char_info = &customFont[index];
        const uint16_t* data = char_info->data;
        
        for (int row = 0; row < char_info->height; row++) {{
            for (int col = 0; col < char_info->width; col++) {{
                uint16_t pixel = data[row * char_info->width + col];
                if (pixel != 0x0000) {{ // Skip transparent pixels
                    display->drawPixel(x + col, y + row, color);
                }}
            }}
        }}
    }}
}}

// Draw text string
void draw{font_prefix.capitalize()}Text(Adafruit_GFX* display, const char* text, int x, int y, uint16_t color) {{
    int currentX = x;
    
    for (int i = 0; text[i] != '\\0'; i++) {{
        int index = getCharIndex(text[i]);
        if (index >= 0 && index < FONT_CHAR_COUNT) {{
            draw{font_prefix.capitalize()}Char(display, text[i], currentX, y, color);
            currentX += customFont[index].width;
        }}
    }}
}}
"""
    
    # Write files
    header_path = output_path.replace('.cpp', '.h')
    
    with open(header_path, 'w') as f:
        f.write(c_header)
    
    with open(output_path, 'w') as f:
        f.write(c_impl)
    
    print(f"Font converted successfully!")
    print(f"Header file: {header_path}")
    print(f"Implementation file: {output_path}")
    print(f"Font size: {font_size}px")
    print(f"Characters: {len(chars)}")
    print(f"Function names: draw{font_prefix.capitalize()}Text(), draw{font_prefix.capitalize()}Char()")

def main():
    if len(sys.argv) < 3:
        print("Usage: python3 convert_font.py <font_path> <output_path> [font_size]")
        print("Example: python3 convert_font.py assets/FATPIXEL.ttf src/custom_font.cpp 16")
        return
    
    font_path = sys.argv[1]
    output_path = sys.argv[2]
    font_size = int(sys.argv[3]) if len(sys.argv) > 3 else 16
    
    if not os.path.exists(font_path):
        print(f"Error: Font file '{font_path}' not found")
        return
    
    try:
        generate_font_array(font_path, output_path, font_size)
    except Exception as e:
        print(f"Error converting font: {e}")

if __name__ == "__main__":
    main() 